import chisel3._
import chisel3.util._
//BUNDLES

class rf_fwd extends Bundle{        //smallest bundle    
    val addr   = Bits(5.W)
    val data   = Bits(64.W)
}
class csr_fwd extends Bundle{
    val addr = Bits(12.W)
    val data = Bits(64.W)
}

class rfFWD extends Bundle{
    val ex  = new rf_fwd
    val mem = new rf_fwd
    val wb  = new rf_fwd
}
class csrFWD extends Bundle{
    val ex  = new csr_fwd
    val mem = new csr_fwd
    val wb  = new csr_fwd
}

class fwd extends Bundle{
    val rf  = new rfFWD
    val csr = new csrFWD
}

class decInfo extends Bundle{
    //all the information generated by ID
    val oprand1    = Bits(64.W)
    val oprand2    = Bits(64.W)
    val rd         = Bits(5.W)      //reg destination
    val wreg       = Bool()         //if this instruction will write the regfile
    val InstType   = Bits(3.W)      //may extend this in the future
    val aluop      = Bits(5.W)
    val branchOp   = new branchOp   //thanks to dce, this will only present in IF
    val storeOp    = new storeOp
    val loadOp     = new loadOp
    val writeCSROp = new writeCSROp
}

class id2Rf extends Bundle{
    val ReadIdx1  = Bits(5.W)
    val ReadIdx2  = Bits(5.W)
}

class rf2Id extends Bundle{
    val RegData1  = Bits(64.W)
    val RegData2  = Bits(64.W)
}

class writeRfOp extends Bundle{
    val en       = Bool()
    val data     = Bits(64.W)
    val addr     = Bits(5.W)
}
class writeCSROp extends Bundle{
    val en      = Bool()
    val addr    = Bits(12.W)    
    val data    = Bits(64.W)
}

class storeOp extends Bundle{       //put to id stage?
    val en       = Bool()
    val addr     = Bits(64.W)
    val data     = Bits(64.W)
    val Width    = Bits(2.W)
    //seems that we can't use 'width' as a name
}

class loadOp extends Bundle{    //id -> ex/mem, because mem need to know this earilier to prepared for the load
    val isLoad   = Bool()
    val addr     = Bits(64.W)
    val Width    = Bits(2.W)
    val sign     = Bool()
    //val dest     = Bits(5.W)    //we already have rd 
}
class branchOp extends Bundle{
    val taken   = Bool()
    val target  = Bits(64.W)
}

class divOP extends Bundle{
    val start   = Bool()
    val a       = Bits(64.W)
    val b       = Bits(64.W)
    val sign    = Bool()        //not implemented yet, leave a mark here
}

class divRes extends Bundle{
    val quo     = Bits(64.W)
    val rem     = Bits(64.W)
    val err     = Bool()
    val finish  = Bool()
}

class ID_2_CSR extends Bundle{      //read
    val addr    = Bits(12.W)
    val wdata   = Bits(64.W)
}

class CSR_2_ID extends Bundle{
    val data        = Bits(64.W)
    val legalWrite  = Bool()        //set en = false if illegal
    val legalRead   = Bool()        //set rd = 0 to disable bypass and throw away the data just read
    //val priv        = Bits(2.W)     //used for xret's check?
    //val xtvec       = Bits(64.W)    //default exception entry
    val xepc        = Bits(64.W)
}

class CSR_2_IF extends Bundle{        //to initialize exception info
    val xtvec   =   Bits(64.W)
    val priv    =   Bits(2.W)
}

class exception extends Bundle{     //to csr
    //WB to CSR
    val cause   = Bits(5.W)
    val int     = Bool()            //mcause's highest bit
    val pc      = Bits(64.W)
    val xtval   = Bits(64.W)        //mtval
    val priv    = Bits(2.W)         //seems not necessary?
    //WB to IF
    val happen  = Bool()
    val new_pc  = Bits(64.W)
}

class IF_excep  extends Bundle{
    val happen  = Bool()
    val new_pc  = Bits(64.W)
}